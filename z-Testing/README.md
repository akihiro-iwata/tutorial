# ソフトウェア(システム)テスト
Wikipediaより引用
```
ソフトウェアテスト（software test）は、コンピュータのプログラムから仕様にない振舞または欠陥（バグ）を見つけ出す作業のことである。  
ソフトウェアテストで見つかったプログラム中の欠陥を修正する作業をデバッグという。  
ソフトウェアテストに成功するとは、テストで欠陥が発見されるか、規定した試験項目にすべて合格するか、規定した品質目標に到達することである。  
目標とした品質には、規定した試験項目にすべて合格することもある。例えば、OS, プログラミング言語では、仕様を満たしているかどうかの適合試験を規定している。  
ソフトウェアテストでは、欠陥が存在することを示すことはできるが、欠陥が存在しないことは証明できない。  
ソフトウェアに仕様にない振舞がないことを保証する作業を証明といい、証明用のシステム、証明しやすい言語も多数存在している。
```

ソフトウェアの世界には「バグを出さない最良の方法はコードを書かないことである」という金言(?)がある。  
どのようなソフトウェア開発プロジェクトであってもバグは必ず産まれる。もし開発期間中にバグが1件も起きていないソフトウェアプロジェクトがあるとすれば、そのソフトウェアは信用しないほうが良い。(※個人の主観)  

以下の図はAmerican Software Testing Qualification Boardが出した「The Relative Cost of a Fixing a Defect」と題する図表である。  
(https://www.astqb.org/press-room/ISTQB_Certification_News_2015_1.html)

![img](https://www.astqb.org/emails/images/030415-3.png)

端的に言えば、「不具合(=バグ)の発見は、遅れれば遅れるほど、修正コストが高くなる」ということをこの図は示している。  
このように、ソフトウェアのテスティングは、単にバグを見つけるだけではない、効率よくかつ早い段階で多くのバグを見つけることが求められる。  

ここでは、こうした制約下において、どのようにテストを「設計」するべきか、そのインプットとアウトプットは何かという点について記載する。  

## テストプロセスの俯瞰
ほぼ全てのソフトウェア開発プロジェクトでは、まず最初にプロジェクト期間をフェーズに区切る作業を行なう。  
一般的に、要件定義・基本設計・詳細設計・単体テスト・結合テスト・総合テスト・ユーザー受け入れテストといった区分に分けられる。  
よく用いられる手法としてVモデルが挙げられる。

![img](https://upload.wikimedia.org/wikipedia/ja/thumb/6/6d/VModelConcept.png/350px-VModelConcept.png)

ただし、これはあくまでもフェーズの定義であり、それぞれのフェーズでの成果物を規定はしていない。それは多くの場合WBSで行われる。  
成果物としてよく引き合いに出されるのが「基本設計書」「詳細設計書」であり、これらはそれぞれ基本設計フェーズ/詳細設計フェーズでの成果物として挙げられる。  
しかし、そもそも「基本」「詳細」という用語が何を指すのかという点について、Vモデルやソフトウェア開発プロセスは定義していない。  
なぜなら、プロジェクトに依って開発するシステムやソフトウェアは異なり、必要な成果物も当然これによって変化するためである。

テストに於いてもこれは同様である。テストプロセスは、「単体テスト」「結合テスト」等の各フェーズにおいて、どのモジュールのどの機能をどのようにテストするのかを定義する。  
この定義が曖昧な場合、各フェーズにおいて何をテストするべきかについてメンバー間で合意が取れず、各々の基準でテストが行われてしまい、テストの粒度が揃わない、テストが行われていないモジュールが発生する、などのトラブルにつながるリスクが発生する。  

Vモデルでは、テストの各フェーズと設計の各フェーズを紐付けている。例えば図の左側の「要求分析」と「受け入れテスト」は直線で紐付けられている。  
このことは、「要求分析」フェーズの成果物(要件定義書等)をインプットに、「受け入れテスト」で行なうテスト対象やコンディションの定義を行なうべきであるということを示す。  
換言すれば、**「要求分析」フェーズの成果物は、「受け入れテスト」フェーズのインプットに耐えうる品質、粒度でなければならない**ということを表す。  

つまり、ソフトウェア開発プロジェクトに於けるテストとはテストフェーズに入ってから始めて設計するのでは遅すぎる。  
要件定義・基本設計といった「上流」工程の段階で、テストプロセスは設計可能でなければならない。  

### Exercise
- 自身が関わっている開発プロジェクトで、どのようなテストフェーズがスケジューリングされているか、確認してください。  
  また各フェーズのイグジットクライテリアや成果物、テストを行なう環境、必要工数や担当メンバーについて、可能な限り明確にしてください。

- 自身が関わっている開発プロジェクトにて、「ユーザー受け入れテスト」フェーズに該当するフェーズはなんと呼ばれていて、いつ行われるか、確認してください。  
  またそのテストは誰が行なうのか、どのような観点で行われるのか(=何をテスト「しない」のか)、過去のプロジェクト事例を参照したり上司に聞くなどして、可能な限り明確にしてください。  

## ソフトウェアの仕様を把握する
ソフトウェアに限らず、何かしらの事物をテストするためには、それが本来どのような形であるべきなのかについて理解しなければならない。  
ソフトウェアにおける「あるべき形」は様々な見方が存在する。ユーザー目線での「あるべき形」は、画面の振舞いや遷移の仕方であるかもしれないし、開発者目線ではデータがnullだった際に投げられる例外の型や、ある関数の引数と返り値に関する事柄かもしれない。  

どの「あるべき形」をどのテストフェーズでテストするかについてテストプロセスの俯瞰で確認した後は、その形を理解することに取り掛かる必要がある。  
ここでの理解とは、単に仕様書や設計書の内容を丸暗記するだけではなく、そもそもその仕様が正しいのか、つまり要件が正しく仕様として落とし込まれているのか、といった観点も必要になる。  
### Exercise
- 自身が関わっている開発プロジェクトにおける任意のソフトウェア・モジュールの仕様と、その仕様の基になっている要件を紐付けてください。  
  ex.) 画面Aの仕様...配置されているオブジェクトやコンポーネント、データの最大桁数等を列挙。当該画面の要件定義書のページ番号や議事録を紐付ける。

## テスト手法、アーキテクチャの設計
各テストフェーズの定義と、そのテストフェーズでテストを行なう際に必要な仕様の理解が終わった後は、テストをどのような手順もしく手法を用いて行なうのかについて定義する。  
例えばプログラム内のビジネスロジックを直接テストするのであれば、テストライブラリを用いる必要がある。  
また画面上の動きや遷移を確かめる際は、どの環境でどの画面のどのコンポーネントをどのように操作するべきか、またそれは人手で行なうのかSelenium等のテストドライバーを用いるのか等も考慮する必要がある。  

### Exercise
- 自身が関わっている開発プロジェクトの各テストフェーズで行われるテストの手法、方法について確認してください。  
  またそのテスト手法を実施するために必要な時間について確認してください。

## テスト設計で議論に挙がる項目
上記に記載したテストプロセスの俯瞰、ソフトウェアの仕様の理解、テスト手法の設計はどのようなテストでも必要な作業である。  
しかしこれらの作業を単純に行えば済むというケースはほぼ存在せず、いずれかの作業にて必ず工数的また時間的制約などに起因するトラブルが発生する。  
ここでは、テストに関するトラブルで代表的なものを取り上げる。  

### 単体テストフェーズで検出されるべきバグが、結合テストフェーズ以降で検知される
先のAmerican Software Testing Qualification Boardの図は「不具合(=バグ)の発見は、遅れれば遅れるほど、修正コストが高くなる」ということを示していた。  
前提として、**バグが発見されたら、その修正を行った後に、そのバグが間違いなく修正されたことを確認するテスト**を必ず行なう必要がある。  
また、その修正による影響範囲内のテストは、たとえ前開実施時に成功していたとしても、再度やり直す必要がある。こうしたテストを**回帰テスト**と呼ぶ。  

単体テストフェーズのバグ修正の回帰テストは、単体テストフェーズの分だけを再実行すれば事足りる。  
しかしこれが例えばユーザー受け入れテストにて発生した場合、バグ修正を行った後に、単体テスト/結合テスト/ユーザー受け入れテストの各フェーズにおけるテストを全てやり直す必要がある。  
たとえバグ自体の影響やバグ修正の難易度が同じだとしても、それが検知される時期によって、その修正に要する工数が変化する。これが「不具合(=バグ)の発見は、遅れれば遅れるほど、修正コストが高くなる」理由である。  

#### 対策
基本的に、あるテストフェーズ内で、本来検知されるべきバグが全て検知されることを期待してはならない。  
ユーザー受け入れテスト等のコンディション数が少ないフェーズならともかく、最もこれが多くなる単体テストフェーズでは特に留意する必要がある。  
ここで大きな力を発揮するのが**テスト自動化**である。テスト自動化を行い、テスト実行に要する労力を削減することで、回帰テストに必要な工数を削減する。  
主にユニットテストやインターフェーステストなどを、JUnitやPHPUnitといったテストライブラリを用いたテストコードを書くことで自動化するアプローチが採用される。  

ただし、全てのテストを自動化するべき、ということをこれは意味しない。テストを自動化するためには、テストコードの作成といった準備のための工数が必要になる。  
例えば画面遷移のテストを自動化するSelenium等は、1つのコンディションを自動化するために数日を要することもある。同じことを人間の手で行えば数分程度で終わることもしばしばある。  

テスト自動化を行なう対象は、ユニットテストといった回帰テストが必要となる度合いが比較的高い部分に限ることを推奨する。  

##### Exercise
- 任意のWebAPIやビジネスロジックについて、JUnitやPHPUnitを用いて、テストコードを作成してください。

### 組み合わせ爆発によるテストコンディション数の爆発
検索を行なう画面があるとする。検索に用いることができるパラメータが10個存在し、それぞれの検索条件はand条件として併用することができる。  
この場合、発生する検索パラメーターの組み合わせは

`10C1 + 10C2 + 10C3 + 10C4 .... 10C10 = 10 + 45 + 120 + .... = 1024`

となる。この全ての組み合わせをテストする場合、コンディション数は1024となる。  
1コンディションの実施に要する時間が10分だとすると、10240分=170時間=1.1月となり、つまり検索画面のテストだけで1月以上かかる計算になる。  

#### 対策
よく行われる手法が、必要となるコンディションを簡易的な表形式等を用いてすべて列挙することである。  
これによりまずコンディションの全量を把握し、そこから現実的な時間に落とし込める範囲までコンディションの数を削減する。  
またより高度な手法としては直交表、オールペア法等が挙げられる。  

##### Exercise
- 組み合わせ爆発が起きそうな画面、モジュールを用いて、必要なコンディションを簡易的な表形式で列挙してください。  

### テスト環境が壊れる
例えばWebAPIが出力するデータを精査するテストを行なうとする。多くの場合、データベースに必要なテストデータを投入し、WebAPIへ所定のパラメータを渡し、戻り値が想定どおりであることを精査する。  
しばしば発生するケースとして、このテストで使うテーブルを同じタイミングで別の開発者が使用しており、テストに齟齬が発生したりデータが壊れる、というものが挙げられる。  
またクラウドやデータセンター側のトラブルによりサーバーが突如ダウンしたり、ネットワークが繋がらなくなる、などのトラブルもある。  

このように、往々にしてテスト環境は「壊れる」。しかしテスト環境が壊れたところで、プロジェクトの納期が変わることはほとんど無い。

#### 対策
- 本番相当の環境をコピーした環境を、各々のPCや専用サーバーに作成し、異なる開発者が同一の環境を使用することを防ぐ。
